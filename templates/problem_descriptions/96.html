<p>You are given a binary string(<em>i.e.</em> with characters <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>) S consisting of characters S<sub>1</sub>, S<sub>2</sub>, …, S<sub>N</sub>. In a single operation, you can choose two indices L and R such that 1 ≤ L ≤ R ≤ N and flip the characters S<sub>L</sub>, S<sub>L+1</sub>, …, S<sub>R</sub>. By flipping, we mean change character <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">1</code> and vice-versa.</p>

<p>You aim is to perform ATMOST one operation such that in final string number of <code class="highlighter-rouge">1</code>s is maximised. If you don’t want to perform the operation, return an empty array. Else, return an array consisting of two elements denoting L and R. If there are multiple solutions, return the lexicographically smallest pair of L and R.</p>

<p><strong>Notes</strong>:   <br />
- Pair (a, b) is lexicographically smaller than pair (c, d) if a &lt; c or, if a == b, then b &lt; d.</p>

<p>For example,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>S = 010

Pair of [L, R] | Final string
_______________|_____________
[1 1]          | 110
[1 2]          | 100
[1 3]          | 101
[2 2]          | 000
[2 3]          | 001

We see that two pairs [1, 1] and [1, 3] give same number of 1s in final string. So, we return [1, 1].
</code></pre>
</div>

<p>Another example,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>If S = 111

No operation can give us more than three 1s in final string. So, we return empty array [].
</code></pre>
</div>